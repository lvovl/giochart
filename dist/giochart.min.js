(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("lodash"), require("react"), require("g2"), require("react-dom"), require("moment"), require("antd"), require("object-hash"));
	else if(typeof define === 'function' && define.amd)
		define(["lodash", "react", "g2", "react-dom", "moment", "antd", "object-hash"], factory);
	else if(typeof exports === 'object')
		exports["GIO"] = factory(require("lodash"), require("react"), require("g2"), require("react-dom"), require("moment"), require("antd"), require("object-hash"));
	else
		root["GIO"] = factory(root["lodash"], root["React"], root["g2"], root["ReactDOM"], root["moment"], root["antd"], root["object-hash"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_9__, __WEBPACK_EXTERNAL_MODULE_13__, __WEBPACK_EXTERNAL_MODULE_16__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	/*
	 * 用来简易使用单图的模块，将获取数据和绘制图表用在一起
	 */
	const lodash_1 = __webpack_require__(2);
	const React = __webpack_require__(3);
	const Chart_1 = __webpack_require__(4);
	exports.Chart = Chart_1.default;
	const ContextListener_1 = __webpack_require__(10);
	exports.ContextListener = ContextListener_1.default;
	const DataSource_1 = __webpack_require__(14);
	exports.DataSource = DataSource_1.default;
	const GrTable_1 = __webpack_require__(12);
	exports.GrTable = GrTable_1.default;
	const utils_1 = __webpack_require__(8);
	exports.retentionSourceSelector = utils_1.retentionSourceSelector;
	exports.retentionIntervalColumns = utils_1.retentionIntervalColumns;
	const retention_utils_1 = __webpack_require__(17);
	exports.getRetention = retention_utils_1.getRetention;
	const timeWeekRange = (timeRange) => {
	    if (!timeRange) {
	        timeRange = "day:8,1";
	    }
	    const [cate, v] = timeRange.split(":");
	    const [start, end] = v.split(",");
	    if (cate === "day") {
	        return parseInt(start, 10) > 7;
	    }
	    else if (cate === "abs") {
	        return (parseInt(end, 10) - parseInt(start, 10)) > (86400000 * 7);
	    }
	    return true;
	};
	// 表格的sorter，在ChartV4里处理，这样可以避免在其他地方用到。
	class ChartV4 extends React.Component {
	    constructor(props) {
	        super(props);
	        // 加载状态
	        this.state = {
	            field: null,
	            order: null
	        };
	    }
	    render() {
	        const props = this.props;
	        const params = lodash_1.clone(props.params);
	        if (props.extraColumns && props.params.attrs) {
	            props.params.attrs.isAddFakeMetric = false;
	        }
	        if (this.state.field) {
	            if (/^dash_/.test(this.state.field)) {
	                params.orders = [{
	                        id: this.state.field,
	                        isDim: true,
	                        orderType: this.state.order === "descend" ? "desc" : "asc"
	                    }];
	            }
	            else {
	                const [id, action] = this.state.field.split("_");
	                const m = lodash_1.find(params.metrics, { id });
	                params.orders = [{
	                        action,
	                        id,
	                        isDim: !m,
	                        orderType: this.state.order === "descend" ? "desc" : "asc"
	                    }];
	            }
	        }
	        return (React.createElement(DataSource_1.default, { params: params, cacheOptions: props.cacheOptions },
	            React.createElement(ContextListener_1.default, { chartType: props.chartType, colorTheme: props.colorTheme, granularities: props.params.granularities, timeRange: props.params.timeRange, adjust: props.adjust, extraColumns: props.extraColumns, groupCol: props.groupCol, range: timeWeekRange(props.params.timeRange), sortHandler: this.sortHandler.bind(this), isThumb: props.isThumb })));
	    }
	    sortHandler(sort) {
	        this.setState(sort);
	    }
	}
	// 根据v3的chartParams计算v4的Scheme转化
	const convertChartParams = (v3Params) => {
	    if (!v3Params.chartType) {
	        return null;
	    }
	    const metrics = v3Params.metrics;
	    let dimensions = v3Params.dimensions || [];
	    let granularities = [];
	    if (v3Params.chartType === "singleNumber") {
	        if (v3Params.aggregateType === "sum") {
	            dimensions = ["tm"];
	        }
	        else {
	            dimensions = ["tm"].concat(dimensions);
	        }
	    }
	    if (["dimensionLine", "dimensionVbar"].includes(v3Params.chartType) && !dimensions.includes("tm")) {
	        granularities = granularities.concat({ id: dimensions[0], top: v3Params.top });
	        dimensions = ["tm"].concat(dimensions);
	    }
	    if (dimensions.length === 0) {
	        dimensions = [v3Params.chartType === "bar" ? "v" : "tm"].concat(dimensions);
	    }
	    if (dimensions.includes("tm")) {
	        // const interval = v3Params.chartType === "singleNumber" ? (v3Params.interval * 1000) : v3Params.interval
	        granularities = granularities.concat({
	            id: "tm",
	            interval: v3Params.interval,
	            period: (v3Params.chartType === "comparison" ? "auto" : undefined)
	        });
	    }
	    if (dimensions.length < 1 || metrics.length < 1) {
	        return null;
	    }
	    // 计算是否有总计: 线图、柱图、维度线图、维度柱图percent， 大数字
	    // aggregation: true | false | NULL -- 是否需要返回聚合值
	    // aggregator: sum | avg | NULL -- 按照那种聚合函数做聚合
	    let aggregation;
	    let aggregator;
	    if (v3Params.chartType === "singleNumber") {
	        aggregation = true;
	        aggregator = v3Params.aggregateType || "sum";
	    }
	    else if (["bar", "abar", "donut"].includes(v3Params.chartType)) {
	        aggregator = "sum";
	        aggregation = false;
	    }
	    const params = {
	        aggregation,
	        aggregator,
	        attrs: v3Params.attrs,
	        dimensions,
	        filters: [v3Params.filter],
	        granularities,
	        id: v3Params.id,
	        name: v3Params.name,
	        limit: ["bar", "abar", "table"].includes(v3Params.chartType) ? v3Params.top : undefined,
	        metrics,
	        orders: v3Params.orders,
	        timeRange: v3Params.timeRange,
	        userTag: v3Params.userTag // 用户分群ID
	    };
	    let chartType = v3Params.chartType;
	    if (chartType !== "table" && params.attrs.rateChange) {
	        params.attrs.rateChange = undefined;
	    }
	    if (chartType === "line" && v3Params.metrics.length < 2) {
	        chartType = "area";
	    }
	    if (chartType.includes("dimension")) {
	        chartType = chartType.replace("dimension", "").toLowerCase();
	    }
	    if (chartType === "line" && v3Params.attrs.subChartType && v3Params.attrs.subChartType !== "seperate") {
	        chartType = "area";
	    }
	    if (chartType === "abar") {
	        chartType = "bar";
	    }
	    if (chartType === "funnel") {
	        params.type = "funnel";
	    }
	    let adjust = v3Params.attrs.subChartType || "dodge";
	    if (chartType === "donut") {
	        adjust = "percent";
	    }
	    if (adjust === "seperate") {
	        adjust = "dodge";
	    }
	    else if (adjust === "total") {
	        adjust = "stack";
	    }
	    const colorTheme = v3Params.attrs.colorTheme;
	    return { adjust, chartType, params, colorTheme };
	};
	exports.convertChartParams = convertChartParams;
	const GioChart = (props) => {
	    if (props.chartType) {
	        return React.createElement(ChartV4, Object.assign({}, props));
	    }
	    const params = props.params;
	    if (props.colorTheme) {
	        params.attrs.colorTheme = props.colorTheme;
	    }
	    const convertV4 = convertChartParams(props.params);
	    if (!convertV4) {
	        return React.createElement("p", null, "\u53C2\u6570\u4E0D\u5408\u6CD5");
	    }
	    if (props.groupCol) {
	        convertV4.params.expanded = true;
	    }
	    return (React.createElement(ChartV4, Object.assign({ extraColumns: props.extraColumns, groupCol: props.groupCol }, convertV4, { cacheOptions: props.cacheOptions, isThumb: props.isThumb })));
	};
	exports.default = GioChart;


/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 图表的绘制，
	 * TODO： 按照声明式去配置
	 */
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	const G2 = __webpack_require__(5);
	const lodash_1 = __webpack_require__(2);
	const React = __webpack_require__(3);
	const ReactDOM = __webpack_require__(6);
	const chartConfig_1 = __webpack_require__(7);
	const utils_1 = __webpack_require__(8);
	const moment = __webpack_require__(9);
	moment.locale("zh-cn");
	const countTick = (maxTick, total) => {
	    const interval = Math.ceil(total / maxTick);
	    return Math.ceil(total / interval);
	};
	const adjustFrame = {
	    // 周期对比图，需要给tooltip增加百分比,同时对齐数据
	    comparison: (frame, metricCols) => {
	        frame.addCol("rate", (record) => (record[metricCols[1]] ? (record[metricCols[0]] / record[metricCols[1]] - 1) : 0));
	        const sourceDef = {
	            rate: {
	                formatter: utils_1.formatPercent,
	                type: "linear"
	            }
	        };
	        // 获取metricid, 计算最大值,统一两条线的区间范围
	        const maxScale = Math.max.apply(null, lodash_1.map(metricCols, (col) => G2.Frame.max(frame, col)));
	        metricCols.forEach((id) => {
	            sourceDef[id] = { max: maxScale };
	        });
	        metricCols.push("rate");
	        return { frame, sourceDef, metricCols };
	    },
	    retentionColumn: (frame, metricCols) => {
	        // 增加流失人数字段，并且计为负数
	        const lossWord = "loss";
	        /*
	        *  retention 多列 步骤
	        *  step1：判断根据chartParams 是否含有comparison_value 为 true
	        *  step2：Frame.filter(frame, "comparison_value")进行分组
	        *  step3：计算每个里面的最大retention 然后添加addcol(lossword) 跟现在一样
	        *  step4：Frame.merge()合并
	        *  step5：返回
	        * */
	        const maxRetention = G2.Frame.max(frame, "retention");
	        frame.addCol(lossWord, (obj) => maxRetention - obj.retention);
	        // chartParams.columns.push({ id: lossWord, name: "流失人数", isDim: false });
	        metricCols = [lossWord, "retention"];
	        /* const sourceDef = {
	          loss: {
	            alias: "流失人数",
	            type: "cat",
	            formatter: (n: number) => formatNumber(Math.abs(n))
	          }
	        };*/
	        return { frame, sourceDef: {}, metricCols };
	    }
	};
	const tooltipMap = {
	    funnel: (ev) => {
	        const l = ev.items.length;
	        for (let i = 0; i * 2 < l; i += 1) {
	            const origin = ev.items[i * 2].point._origin;
	            const origin2 = ev.items[i * 2 + 1].point._origin;
	            ev.items[i] = ev.items[i * 2];
	            ev.items[i].value = `${ev.items[2 * i].name}: ${utils_1.formatPercent(origin.conversion_rate)}, ` +
	                `${ev.items[2 * i + 1].name}: ${origin2.conversion}`;
	            ev.items[i].name = origin.comparison_value || origin.metric_name;
	        }
	        ev.items.splice(l / 2, l / 2);
	    },
	    comparison: (ev) => {
	        // console.log(ev);
	        /*ev.items[0] = ev.items[1];
	        ev.items[0].name = getTooltipName(ev.items[0], "tm", false);
	        if (ev.items.length > 2) {
	          ev.items[1] = ev.items[2];
	          ev.items[1].name = getTooltipName(ev.items[1], "tm_", false);
	        }*/
	        ev.items.splice(ev.items.length - 1);
	    },
	    retention: (ev) => {
	        const itemsGroup = lodash_1.groupBy(ev.items, "color");
	        const keys = Object.keys(itemsGroup);
	        ev.items.splice(0);
	        keys.forEach((key) => {
	            const items = itemsGroup[key];
	            const value = items.map((item) => (item.name + ": " + item.value)).splice(1).join(", ");
	            let combineValue = items[0].value;
	            if (value.length) {
	                combineValue = combineValue + ", " + value;
	            }
	            ev.items.push(lodash_1.assign({}, items[0], { value: combineValue }));
	        });
	    }
	};
	class Chart extends React.Component {
	    constructor(props) {
	        super();
	        // private selectMode: string = "multiple";
	        this.lastSelectedShape = null;
	        // G2 的主题有bug，legend读的是G2.Theme的颜色，因此直接覆盖Theme更合适
	        const theme = G2.Util.mix(true, G2.Theme, chartConfig_1.CHARTTHEME);
	        G2.Global.setTheme(theme);
	        G2.Global.animate = navigator.hardwareConcurrency && navigator.hardwareConcurrency > 7;
	        this.inspectDom = null;
	    }
	    render() {
	        return React.createElement("div", { className: "giochart", style: this.props.style });
	    }
	    // 按理不需要绘制对不上的图
	    isValidParams(chartParams, source) {
	        if (chartParams.chartType === "comparison" && source.length && !source[0].tm_) {
	            return false;
	        }
	        else if (chartParams.chartType === "bar") {
	            // 是否有非tm的维度
	            const dim = lodash_1.find(chartParams.columns, { isDim: true });
	            return dim.id !== "tm";
	        }
	        return true;
	    }
	    // 这个函数是用来区分changeData还是draw, 通常尽量不要用componentWillReceiveProps
	    componentWillReceiveProps(nextProps) {
	        if (lodash_1.isEmpty(nextProps.source)) {
	            return;
	        }
	        const source = nextProps.source;
	        // 若是chartParams和source不合法,那说明数据没有传输到，
	        if (!this.isValidParams(nextProps.chartParams, nextProps.source)) {
	            return;
	        }
	        if (!lodash_1.isEmpty(nextProps.selected)) {
	            const dimCols = lodash_1.map(lodash_1.filter(nextProps.chartParams.columns, { isDim: true }), "id");
	            const filteredSelected = lodash_1.filter(nextProps.selected, (item) => lodash_1.isEmpty(lodash_1.pick(item, dimCols)));
	            if (lodash_1.isEmpty(filteredSelected)) {
	                return;
	            }
	            const filterSource = lodash_1.filter(source, (sourceItem) => lodash_1.some(filteredSelected, (selectedItem) => lodash_1.isMatch(sourceItem, selectedItem)));
	            this.changeData(filterSource || source);
	        }
	        else {
	            if (JSON.stringify(this.props.chartParams) !== JSON.stringify(nextProps.chartParams)) {
	                if (this.chart) {
	                    this.chart.destroy();
	                    // this.chart.get("container").innerHTML = "";
	                    ReactDOM.findDOMNode(this).innerHTML = "";
	                }
	                this.drawChart(nextProps.chartParams, source, nextProps.isThumb);
	            }
	            else if (JSON.stringify(source) !== JSON.stringify(this.props.source)) {
	                // this.changeData(source);
	                if (this.chart) {
	                    this.chart.destroy();
	                    ReactDOM.findDOMNode(this).innerHTML = "";
	                }
	                this.drawChart(nextProps.chartParams, source, nextProps.isThumb);
	            }
	        }
	    }
	    changeData(source) {
	        if (this.chart) {
	            const chartParams = this.props.chartParams;
	            const chartCfg = chartConfig_1.CHARTTYPEMAP[chartParams.chartType];
	            // 检验是否需要合并对做处理
	            let frame = new G2.Frame(source);
	            // 需要多值域合并
	            const metricCols = lodash_1.map(lodash_1.filter(chartParams.columns, { isDim: false }), "id");
	            const dimCols = lodash_1.map(lodash_1.filter(chartParams.columns, { isDim: true }), "id");
	            if (chartCfg.combineMetrics && metricCols.length > 1) {
	                frame = G2.Frame.combinColumns(frame, metricCols, "val", "metric", dimCols);
	                const metricNames = lodash_1.map(lodash_1.filter(chartParams.columns, { isDim: false }), "name");
	            }
	            this.chart.changeData(frame);
	        }
	        else {
	            this.drawChart(this.props.chartParams, source, this.props.isThumb);
	        }
	    }
	    componentDidMount() {
	        const { chartParams, isThumb, source } = this.props;
	        if (!this.isValidParams(chartParams, source)) {
	            return;
	        }
	        if (source) {
	            if (this.chart) {
	                this.chart.destroy();
	            }
	            this.drawChart(chartParams, source, isThumb);
	        }
	    }
	    componentWillUnmount() {
	        if (this.chart) {
	            this.chart.destroy();
	            // ReactDOM.findDOMNode(this).innerHTML = "";
	        }
	    }
	    washRecord(frame, metricCols) {
	        return G2.Frame.filter(frame, (obj) => metricCols.every((col) => (typeof obj[col] === "number" || obj[col] === undefined)));
	    }
	    getDimValues(frame, columns, columnId) {
	        let values = null;
	        values = lodash_1.map(frame.data, (data) => {
	            // const col: any = columns.filter((c) => c.id === "retention_" + data.turn );
	            return data.turn;
	        });
	        return { id: columnId, dimValues: values };
	    }
	    combineMetrics(frame, cfg, columns, preRenderData) {
	        let [dimCols, metricCols] = lodash_1.invokeMap(lodash_1.groupBy(columns, "isDim"), "map", (n) => n.id);
	        const METRICDIM = "metric";
	        const METRICVAL = "val";
	        // make scales;
	        if (cfg.emptyDim) {
	            dimCols = [null].concat(dimCols);
	        }
	        let sourceDef = null;
	        if (preRenderData) {
	            const preRenderSource = preRenderData(frame, metricCols);
	            frame = preRenderSource.frame;
	            sourceDef = preRenderSource.sourceDef;
	            metricCols = preRenderSource.metricCols;
	        }
	        if (!cfg.combineMetrics && (cfg.geom === "point" || lodash_1.isArray(cfg.geom) || cfg.withRate || (metricCols && metricCols.length < 2))) {
	            return {
	                frame,
	                dimCols,
	                metricCols,
	                scales: this.buildScales(columns, cfg.geom, sourceDef)
	            };
	        }
	        // retention 下 metricDict 对应不上 TODO: fix
	        const metricNames = lodash_1.map(lodash_1.filter(columns, { isDim: false }), "name");
	        let metricDict = lodash_1.fromPairs(lodash_1.zip(metricCols, metricNames));
	        // retenton 特殊处理
	        if (metricCols[0] === "loss" && metricCols[1] === "retention") {
	            metricDict = {};
	            metricDict.loss = "未留存人数";
	            metricDict.retention = "留存人数";
	        }
	        // retention 多列要保留 comparison_value 字段 最后绘图参考G2线上demo
	        frame = G2.Frame.combinColumns(frame, metricCols, METRICVAL, METRICDIM, dimCols);
	        dimCols.push(METRICDIM);
	        const examCol = lodash_1.find(columns, { id: metricCols[0] });
	        const isRate = examCol ? examCol.isRate : false;
	        columns = lodash_1.filter(columns, { isDim: true }).concat([
	            { id: "metric", isDim: true, formatterMap: metricDict },
	            { id: "val", isRate, isDim: false }
	        ]);
	        // TODO: this.sortLegend();
	        return {
	            frame,
	            dimCols,
	            metricCols: [METRICVAL],
	            scales: this.buildScales(columns, cfg.geom, sourceDef)
	        };
	    }
	    calculateAdjust(adjust, geom) {
	        if (adjust === "percent") {
	            return "stack";
	        }
	        if ("line" === geom || "interval" !== geom && adjust === "dodge") {
	            return undefined;
	        }
	        return adjust;
	    }
	    calculatePosition(metricCols, dimCols, chartCfg, adjust) {
	        let postion;
	        if (chartCfg.geom === "point") {
	            postion = { pos: metricCols[0] + "*" + metricCols[1], x: metricCols[0], y: metricCols[1] };
	        }
	        else if (dimCols[0]) {
	            postion = { pos: dimCols[0] + "*" + metricCols[0], x: dimCols[0], y: metricCols[0] };
	        }
	        else {
	            postion = { pos: metricCols[0], x: undefined, y: undefined };
	        }
	        if (adjust === "percent") {
	            return { pos: G2.Stat.summary.percent(postion.pos), x: postion.x, y: postion.y };
	        }
	        return postion;
	    }
	    calculateColor(dimCols, colorTheme, gradual) {
	        if (colorTheme) {
	            return gradual ? `l(90) 0:rgba(${colorTheme}, 0.8) 1:rgba(${colorTheme}, 0.1)` : `rgb(${colorTheme})`;
	            // return `rgb(${colorTheme})`;
	        }
	        else if (dimCols.length > 1) {
	            return dimCols[1];
	        }
	        return;
	    }
	    calculatePlot(frame, chartCfg, dimCols, chartType) {
	        let colPixels = null;
	        let pixels = null;
	        const margin = [20, 30, 30, 50];
	        if (chartCfg.isThumb) {
	            return { margin: [0, 0, 0, 0], colPixels: null };
	        }
	        if (chartCfg.transpose) {
	            const maxWordLength = Math.max.apply(null, lodash_1.map(frame.colArray(dimCols[0]), "length"));
	            const c = document.createElement("canvas");
	            // Get the context of the dummy canvas
	            const ctx = c.getContext("2d");
	            // Set the context.font to the font
	            ctx.font = chartConfig_1.CHARTTHEME.fontSize + " " + chartConfig_1.CHARTTHEME.fontFamily;
	            // Measure the string
	            pixels = frame.colArray(dimCols[0]).map((col) => ctx.measureText(col).width);
	            margin[3] = 5 + chartConfig_1.CHARTTHEME.labelOffset + Math.min(chartConfig_1.CHARTTHEME.maxPlotLength, Math.max(...pixels));
	            colPixels = lodash_1.assign({}, ...frame.colArray(dimCols[0]).map((k, i) => ({ [k]: pixels[i] })));
	        }
	        if (!chartCfg.periodOverPeriod && lodash_1.isArray(chartCfg.geom)) {
	            margin[1] = 50;
	        }
	        if (lodash_1.isArray(chartCfg.geom)) {
	            margin[2] = 70;
	        }
	        if (chartType === "area" || chartType === "bubble" || chartType === "line" || chartType === "vbar") {
	            margin[3] = 10 + chartConfig_1.CHARTTHEME.titleOffset;
	        }
	        // 如果没有legend, 通常左边会有标题显示
	        return { margin, colPixels };
	    }
	    drawChart(chartParams, source, isThumb = false) {
	        // 防止destroy删除父节点
	        const dom = document.createElement("div");
	        dom.style.height = "100%";
	        ReactDOM.findDOMNode(this).appendChild(dom);
	        const canvasRect = dom.getBoundingClientRect();
	        // 建立Frame, 并后期修正
	        const chartConfig = chartConfig_1.CHARTTYPEMAP[chartParams.chartType];
	        let frame = new G2.Frame(source);
	        // 多值域合并,并返回新的columns
	        const chartType = chartParams.chartType;
	        const lastCombined = this.combineMetrics(frame, chartConfig, chartParams.columns, adjustFrame[chartType]);
	        const metricCols = lastCombined.metricCols;
	        const dimCols = lastCombined.dimCols;
	        frame = lastCombined.frame;
	        const scales = lastCombined.scales;
	        // 清洗脏数据
	        frame = this.washRecord(frame, metricCols);
	        // x轴tickCount
	        if (scales.tm) {
	            // 寻找时间粒度
	            const tmGran = lodash_1.find(chartParams.granularities, { id: "tm" });
	            const tmInterval = tmGran.interval;
	            lodash_1.merge(scales.tm, {
	                tickInterval: utils_1.countTickCount(frame, canvasRect.width, tmInterval),
	                formatter: utils_1.getTmFormat(tmInterval),
	                axisFormatter: utils_1.getAxisFormat(tmInterval)
	            });
	            window.onresize = () => {
	                const currentRect = dom.getBoundingClientRect();
	                const tm = lodash_1.merge({}, scales.tm, {
	                    tickInterval: utils_1.countTickCount(frame, currentRect.width, tmInterval),
	                    formatter: utils_1.getTmFormat(tmInterval),
	                    axisFormatter: utils_1.getAxisFormat(tmInterval)
	                });
	                chart.col(dimCols[0], tm);
	                chart.repaint();
	            };
	        }
	        else if (chartConfig.geom !== "point" && scales[dimCols[0]]) {
	            const maxTicks = G2.Frame.group(frame, dimCols[0]).length;
	            if (scales[dimCols[0]].type === "linear") {
	                scales[dimCols[0]].tickInterval = Math.ceil(60 * maxTicks / (canvasRect.width - 100));
	            }
	            if (chartConfig_1.ResizeChartType.includes(chartType) && scales[dimCols[0]].values) {
	                const origValues = scales[dimCols[0]].values;
	                window.onresize = () => {
	                    const currentRect = dom.getBoundingClientRect();
	                    const tickC = Math.ceil(60 * maxTicks / (currentRect.width - 100));
	                    if (tickC > 1) {
	                        const newValues = utils_1.filterValuesByTickCount(tickC, origValues);
	                        const newFrame = utils_1.mergeFrame(frame, dimCols[0], newValues.indexs);
	                        chart.col(dimCols[0], lodash_1.assign({}, scales[dimCols[0]], { tickCount: newValues.values.length, values: newValues.values }));
	                        chart.changeData(newFrame);
	                    }
	                    else {
	                        chart.col(dimCols[0], lodash_1.assign({}, scales[dimCols[0]], { tickCount: origValues.length, values: origValues }));
	                        chart.changeData(frame);
	                    }
	                };
	            }
	        }
	        // 百分比
	        if (chartParams.adjust === "percent") {
	            scales["..percent"] = { formatter: utils_1.formatPercent, type: "linear" };
	        }
	        // legend
	        let legendHeight = 0;
	        if (dimCols.length > 1 && !lodash_1.isArray(chartConfig.geom)) {
	            const colNames = frame.colArray(dimCols[1]);
	            const legendDom = this.drawLegend(dimCols[1], lodash_1.uniq(colNames), scales[dimCols[1]], chartConfig.legendSingleMode, chartConfig.legendPosition === "top" ? chartParams.aggregator.values : null, chartParams.attrs ? chartParams.attrs.selection : null, chartType);
	            if (chartConfig.legendPosition === "top") {
	                legendDom.className = "giochart-legends top-legends";
	                ReactDOM.findDOMNode(this).insertBefore(legendDom, dom);
	            }
	            else {
	                ReactDOM.findDOMNode(this).appendChild(legendDom);
	            }
	            legendHeight = legendDom.getBoundingClientRect().height;
	        }
	        dom.style.height = `calc( 100% - ${legendHeight}px)`;
	        // canvasHeight = canvasRect.height - legendHeight;
	        // geom
	        const adjust = this.calculateAdjust(chartParams.adjust, chartConfig.geom);
	        // position
	        // console.log(frame.s());
	        const position = this.calculatePosition(metricCols, dimCols, chartConfig, chartParams.adjust);
	        // position = G2.Stat.summary.sum(position);
	        // color/shape
	        const color = this.calculateColor(dimCols, chartConfig.colorTheme ? (chartParams.colorTheme || chartConfig.colorTheme) : null, (chartType === "singleNum"));
	        // render配置
	        let canvasHeight = canvasRect.height - legendHeight;
	        if (chartConfig.transpose) {
	            canvasHeight = Math.max(15 * frame.rowCount(), canvasHeight);
	        }
	        const plot = this.calculatePlot(frame, chartConfig, dimCols, chartParams.chartType);
	        const chart = new G2.Chart({
	            container: dom,
	            forceFit: true,
	            height: canvasHeight || 300,
	            plotCfg: {
	                margin: plot.margin
	            }
	        });
	        const origValues = scales[dimCols[0]].values;
	        const maxTicks = G2.Frame.group(frame, dimCols[0]).length;
	        const tickC = Math.ceil(60 * maxTicks / (canvasRect.width - 100));
	        if (tickC > 1 && chartConfig_1.ResizeChartType.includes(chartType) && origValues) {
	            const newValues = utils_1.filterValuesByTickCount(tickC, origValues);
	            const newFrame = utils_1.mergeFrame(frame, dimCols[0], newValues.indexs);
	            const sal = lodash_1.assign({}, scales[dimCols[0]], { tickCount: newValues.values.length, values: newValues.values });
	            const newScales = lodash_1.assign({}, scales, { turn: sal });
	            chart.source(newFrame, newScales);
	        }
	        else {
	            chart.source(frame, scales);
	        }
	        if (!chartConfig.withRate && !metricCols.includes("val")) {
	            metricCols.forEach((s) => {
	                chart.axis(s, { title: { fill: "#999", textAlign: "center" } });
	            });
	        }
	        if (scales.tm) {
	            chart.axis("tm", {
	                formatter: scales.tm.axisFormatter
	            });
	        }
	        // chart.axis(chartConfig.isThumb ? false : chartConfig.axis);
	        let coord = null;
	        if (chartConfig.coord) {
	            coord = chart.coord(chartConfig.coord, {
	                radius: 1,
	                inner: 0.7
	            });
	        }
	        else {
	            coord = chart.coord("rect");
	        }
	        if (chartConfig.transpose) {
	            chart.axis(position.x, {
	                formatter: (val) => {
	                    if (plot.colPixels) {
	                        if (plot.colPixels[val] <= chartConfig_1.CHARTTHEME.maxPlotLength) {
	                            return val;
	                        }
	                        else {
	                            const c = document.createElement("canvas");
	                            const ctx = c.getContext("2d");
	                            ctx.font = chartConfig_1.CHARTTHEME.fontSize + " " + chartConfig_1.CHARTTHEME.fontFamily;
	                            const ellipsis = ctx.measureText("...").width;
	                            const chars = val.split("").map((char) => ctx.measureText(char).width);
	                            let plotLength = 0;
	                            let i = 0;
	                            while (plotLength + ellipsis <= chartConfig_1.CHARTTHEME.maxPlotLength) {
	                                plotLength += chars[i];
	                                i++;
	                            }
	                            return val.substring(0, i - 1) + "...";
	                        }
	                    }
	                    return val;
	                },
	                labelOffset: chartConfig_1.CHARTTHEME.labelOffset,
	            });
	        }
	        if (chartType === "area" || chartType === "bubble" || chartType === "line" || chartType === "vbar ") {
	            chart.axis(position.y, {
	                titleOffset: chartConfig_1.CHARTTHEME.titleOffset,
	                title: {
	                    fontSize: "12",
	                    textAlign: "center",
	                    fill: "#999"
	                }
	            });
	        }
	        if (chartConfig.transpose) {
	            coord.transpose(chartConfig.transpose);
	            if (chartConfig.reflect) {
	                coord.reflect(chartConfig.reflect);
	            }
	        }
	        const geomType = lodash_1.isArray(chartConfig.geom) ? chartConfig.geom[0] : chartConfig.geom;
	        // 参考线,周期对比图线在后
	        if (lodash_1.isArray(chartConfig.geom) && chartConfig.periodOverPeriod) {
	            chart[chartConfig.geom[1]]().position(dimCols[0] + "*" + metricCols[1]).color("#ccc").tooltip("");
	            chart.axis(metricCols[0], false);
	        }
	        // 本来应该画在legend里面的，但是需要chart.filter
	        if (chartConfig.legendSingleMode && dimCols.length > 1) {
	            const colNames = frame.colArray(dimCols[1]);
	            chart.filter(dimCols[1], [colNames[0]]);
	        }
	        const geom = chart[geomType](adjust);
	        if (geomType === "area" && dimCols.length < 2) {
	            geom.size(2);
	        } // 参考线，双轴图线在后
	        if (lodash_1.isArray(chartConfig.geom) && !chartConfig.periodOverPeriod) {
	            chart[chartConfig.geom[1]]().position(dimCols[0] + "*" + metricCols[1]).color("#ccc");
	        }
	        geom.position(position.pos);
	        if (!chartConfig.shape && color) {
	            if (chartParams.attrs && chartParams.attrs.selection.length > 0) {
	                const colorArray = G2.Global.colors.trend.filter((c, i) => chartParams.attrs.selection.includes(i));
	                geom.color(color, colorArray);
	            }
	            else {
	                geom.color(color);
	            }
	        }
	        if (chartConfig.shape) {
	            if (typeof chartConfig.shape === "string") {
	                geom.shape(chartConfig.shape);
	            }
	            else {
	                geom.color("#B8E986").shape(dimCols[1], chartConfig.shape);
	            }
	        }
	        if (chartConfig.geom === "point" && metricCols.length > 2) {
	            geom.size(metricCols[2], 40, 2);
	        }
	        if (chartConfig.label) {
	            // geom.label(chartConfig.label);
	            geom.label(metricCols[0], {
	                offset: 5
	            });
	        }
	        if (chartConfig.isThumb || chartConfig.tooltip) {
	            geom.tooltip(chartConfig.isThumb ? false : chartConfig.tooltip);
	        }
	        // legend bottom 默认距离canvas底部为30px x轴labe默认距离x轴约20px
	        chart.legend(lodash_1.isArray(chartConfig.geom) ? { position: "bottom" } : false);
	        if (tooltipMap[chartType]) {
	            if (chartType === "retention" && color) {
	                geom.tooltip(color + "*" + metricCols.join("*"));
	            }
	            else {
	                geom.tooltip(metricCols.join("*"));
	            }
	            if (metricCols.includes("rate")) {
	                //  console.log("rate");
	                chart.tooltip(true, { map: { title: "rate" } });
	            }
	            chart.on("tooltipchange", tooltipMap[chartType]);
	        }
	        chart.tooltip(true, {
	            custom: true,
	            html: '<div class="ac-tooltip" style="position:absolute;visibility: hidden;"><span class="ac-title"></span><ul class="ac-list"></ul></div>',
	            itemTpl: '<li><svg fill={color} class="ac-svg"><circle cx="3" cy="7" r="3"/></svg>{name}: {value}</li>',
	            offset: 10
	        });
	        // 参考线
	        // geom.selected(true, {
	        //   selectedMode: "single", // "multiple" || "single"
	        //   style: {fill: "#fe9929"}
	        // });
	        // chart.on("itemselected", (ev: any) => {
	        //   const data = ev.data;
	        //   if (data) {
	        //     console.log(data._origin);
	        //     console.log(data.x);
	        //     console.log(data.y);
	        //   }
	        //   if (this.inspectDom === null) {
	        //     this.inspectDom = this.createInspectDom(data, scales);
	        //     ReactDOM.findDOMNode(this).appendChild(this.inspectDom);
	        //   }else {
	        //     this.repaintInspectDom(this.inspectDom, data, scales);
	        //   }
	        // });
	        /*
	        const selectCols = (chartConfig.geom === "point" ? metricCols.slice(0, 2) : dimCols) as string[];
	        chart.on("plotclick", (evt: any) => this.selectHandler(evt, selectCols));
	        chart.on("itemunselected", (evt: any) => this.unselectHandler(evt, selectCols));
	        */
	        if (chartConfig.aggregator) {
	            const aggScale = scales[metricCols[0]];
	            chart.guide().html([-5.5, 0], "<div style=\"text-align:center;white-space: nowrap;\"><p style=\"color:#999;font-size:12px;\">总" +
	                aggScale.alias + "</p>" +
	                "<p style=\"color:#333;font-size:22px;\">" + aggScale.formatter(chartParams.aggregator.values[0]) + "</p></div>");
	        }
	        chart.render();
	        this.chart = chart;
	    }
	    // 不能用state去绘制，因为时间顺序的问题
	    drawLegend(dim, coloredDim, scaleDef, isSingle, aggregates, colorSelection, chartType) {
	        const dom = document.createElement("div");
	        dom.className = "giochart-legends";
	        let colorArray = null;
	        if (colorSelection && colorSelection.length === coloredDim.length) {
	            colorArray = G2.Global.colors.trend;
	        }
	        else {
	            colorArray = G2.Global.colors.default;
	            colorSelection = Array.apply(null, Array(20)).map((v, i) => i);
	        }
	        const ul = document.createElement("ul");
	        ul.innerHTML = coloredDim.map((n, i) => {
	            const li = `<li data-val="${n}" ` +
	                `title="${scaleDef.formatter ? scaleDef.formatter(n) : n}" class="${isSingle && i > 0 ? "disabled" : ""}">`;
	            let svg = null;
	            if (chartType === "retentionColumn") {
	                if (n === "loss") {
	                    svg = `<svg><rect width="11" height="11" zIndex="3" stroke="#B8E986" fill="white" stroke-width="2" stroke-dasharray="3,2"></rect></svg>`;
	                }
	                else {
	                    svg = `<svg fill="#B8E986"><rect width="11" height="11" zIndex="3" stroke-dasharray="3,2"></rect></svg>`;
	                }
	            }
	            else {
	                svg = `<svg fill="${colorArray[colorSelection[i] % colorArray.length]}"><rect width="11" height="11" zIndex="3"></rect></svg>`;
	            }
	            let name = n;
	            if (scaleDef.mapValues) {
	                name = scaleDef.mapValues[i];
	            }
	            else if (scaleDef.formatter) {
	                name = scaleDef.formatter(n);
	            }
	            return li + svg + name +
	                (aggregates ? `：<span>${utils_1.formatPercent(aggregates[i])}</span>` : "") +
	                `</li>`;
	            // `<li data-val="${n}" ` +
	            //   `title="${scaleDef.formatter ? scaleDef.formatter(n) : n}" class="${isSingle && i > 0 ? "disabled" : ""}">` +
	            //   `<svg fill="${colorArray[colorSelection[i] % colorArray.length]}"><rect width="11" height="11" zIndex="3"></rect></svg>` +
	            //   (scaleDef.formatter ? scaleDef.formatter(n) : n) +
	            //    (aggregates ? `：<span>${formatPercent(aggregates[i])}</span>` : "") +
	            // `</li>`
	        }).join("");
	        dom.appendChild(ul);
	        this.legends = coloredDim.map((n, i) => ({
	            color: G2.Global.colors.default[i],
	            dotDom: dom.querySelector(`li:nth-child(${1 + i})`),
	            isChecked: !(isSingle && i > 0),
	            name: n
	        }));
	        // 绑定事件
	        ul.addEventListener("click", (e) => {
	            let target = e.target;
	            const currentTarget = e.currentTarget;
	            while (currentTarget.contains(target)) {
	                const value = target.getAttribute("data-val");
	                if (value) {
	                    e.stopPropagation();
	                    this.filter(dim, value, isSingle);
	                    return;
	                }
	                target = target.parentNode;
	            }
	        });
	        if (aggregates) {
	            return dom;
	        }
	        // 超出部分通过箭头scroll
	        const scroller = document.createElement("div");
	        scroller.className = "giochart-legend-scroller";
	        scroller.innerHTML = '<span><i class="anticon anticon-caret-up" data-action="up"></i></span>' +
	            '<span><i class="anticon anticon-caret-down" data-action="down"></i></span>';
	        dom.appendChild(scroller);
	        let scrollTop = 0;
	        scroller.addEventListener("click", (e) => {
	            e.stopPropagation();
	            const target = e.target;
	            const cHeight = ul.getBoundingClientRect().height;
	            const action = target.getAttribute("data-action");
	            if (action === "up" && scrollTop > 19) {
	                scrollTop -= 20;
	                ul.style.transform = `translate(0, ${-scrollTop}px)`;
	            }
	            else if (action === "down" && cHeight > scrollTop + 70) {
	                scrollTop += 20;
	                ul.style.transform = `translate(0, ${-scrollTop}px)`;
	            }
	        });
	        // TODO: 这段好像没用
	        document.body.addEventListener("resize", (e) => {
	            const domHeight = dom.getBoundingClientRect().height;
	            const cHeight = ul.getBoundingClientRect().height;
	            dom.style.textAlign = (!isSingle && domHeight < 21) ? "center" : "left";
	            scroller.style.display = cHeight > 70 ? "block" : "none";
	        });
	        const domHeight = dom.getBoundingClientRect().height;
	        const cHeight = ul.getBoundingClientRect().height;
	        ul.style.textAlign = domHeight < 25 ? "center" : "left";
	        scroller.style.display = cHeight > 70 ? "block" : "none";
	        // document.body.dispatchEvent("resize");
	        // dom.onResize();
	        return dom;
	    }
	    filter(dim, name, isSingle) {
	        const obj = lodash_1.find(this.legends, { name });
	        const filterNames = [];
	        if (obj.isChecked && isSingle) {
	            return;
	        }
	        obj.isChecked = !obj.isChecked;
	        this.legends.forEach((v) => {
	            if (isSingle ? v.name === obj.name : v.isChecked) {
	                v.isChecked = true;
	                v.dotDom.className = "";
	                filterNames.push(v.name);
	            }
	            else {
	                v.dotDom.className = "disabled";
	                v.isChecked = false;
	            }
	        });
	        this.chart.filter(dim, filterNames);
	        // this.props.onFiltered && this.props.onFiltered(dim, filterNames);
	        this.chart.repaint();
	    }
	    unselectHandler(ev, selectCols) {
	        // console.log('unselectHandler', ev, selectCols);
	        return;
	    }
	    selectHandler(ev, selectCols) {
	        const shape = ev.shape;
	        if (shape) {
	            const mode = ev.geom._attrs.selectedCfg.selectedMode;
	            if (shape.get("selected")) {
	                const item = shape.get("origin");
	                // 过滤
	                const metaSelected = lodash_1.pick(item._origin, selectCols);
	                // this.props.select(metaSelected, this.lastSelectedShape);
	                // this.lastSelectedShape = metaSelected;
	            }
	            else {
	                const item = shape.get("origin");
	                // this.props.select(null, pick(item._origin, selectCols));
	            }
	        }
	    }
	    buildScales(columns, geom, defaultScaleDef) {
	        const scaleDef = {};
	        if (typeof geom !== "string") {
	            geom = geom[0];
	        }
	        // 日期在外面设置
	        columns.forEach((m, i) => {
	            if (m.id === "tm") {
	                scaleDef.tm = {
	                    type: geom === "interval" ? "timeCat" : "time",
	                    // TODO 这里用来显示ToolTip, axis的显示，在chart.axis里面定义
	                    formatter: (v) => moment.unix(v / 1000).format(v % 864e5 === 576e5 ? "MM-DD ddd" : "HH:mm")
	                };
	            }
	            else if (m.isDim) {
	                scaleDef[m.id] = {
	                    alias: m.name,
	                    type: "cat"
	                };
	                if (m.formatterMap) {
	                    scaleDef[m.id].formatter = (n) => m.formatterMap[n];
	                }
	                if (m.values) {
	                    if (i === 0) {
	                        scaleDef[m.id].values = m.values;
	                    }
	                    else {
	                        scaleDef[m.id].mapValues = m.values;
	                    }
	                }
	            }
	            else {
	                scaleDef[m.id] = {
	                    alias: m.name,
	                    type: "linear",
	                    min: 0,
	                    max: m.isRate ? 1 : undefined,
	                    formatter: m.isRate ? utils_1.formatPercent : utils_1.formatNumber,
	                };
	            }
	        });
	        if (defaultScaleDef) {
	            return lodash_1.defaultsDeep(defaultScaleDef, scaleDef);
	        }
	        return scaleDef;
	    }
	}
	const getTooltipName = (item, key, isHour) => {
	    const point = item.point._origin[key];
	    return moment.unix(point / 1000).format("YYYY-MM-DD ddd" + (isHour ? " HH:mm" : ""));
	};
	exports.default = Chart;


/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_5__;

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_6__;

/***/ },
/* 7 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// TODO: 将图表类型变成不同步骤的组合
	exports.CHARTTYPEMAP = {
	    area: { geom: "area" },
	    bar: { geom: "interval", reflect: "y", transpose: true, label: true },
	    bubble: { geom: "point", shape: "circle" },
	    comparison: { geom: ["area", "line"], periodOverPeriod: true, colorTheme: "252, 95, 58" },
	    dualaxis: { geom: ["interval", "line"] },
	    funnel: { geom: "line", withRate: true },
	    funnelChart: { geom: "line", withRate: true, legendPosition: "top" },
	    line: { geom: "line" },
	    retentionColumn: { geom: "interval", shape: ["hollowRect", "stroke"], withRate: true, combineMetrics: true },
	    retention: { geom: "line", withRate: true },
	    singleNumber: { geom: "area", shape: "smooth", isThumb: true, colorTheme: "252, 95, 58" },
	    vbar: { geom: "interval" },
	    donut: { geom: "interval", emptyDim: true, coord: "theta", aggregator: true }
	};
	const COLORS = [
	    "#5FB6C7", "#FFD159",
	    "#C9C77C", "#FA7413",
	    "#D6DCE3", "#6F5D45",
	    "#FDF0A1", "#bf1f41",
	    "#A1EBDE", "#CBBD8C",
	    "#B96285", "#8a73c9",
	    "#005a03", "#320096",
	    "#673000", "#2d396b"
	];
	const TRENDCOLORS = [
	    "#C9DE00", "#FF4500",
	    "#00BFD8", "#FFEC00",
	    "#734A3F", "#375167",
	    "#587E8D", "#9E9E9E",
	    "#FFBF00", "#3C4FBC",
	    "#6AB626", "#AB02B6",
	    "#00ABFB", "#6F31BE",
	    "#FE0061", "#00B341",
	    "#009988", "#FF2825",
	    "#FFA300", "#0096FB"
	];
	// G2 的主题有bug，legend读的是G2.Theme的颜色，因此直接覆盖Theme更合适
	exports.CHARTTHEME = {
	    animate: false,
	    labelOffset: 15,
	    titleOffset: 60,
	    axis: {
	        bottom: {
	            labels: { autoRotate: false },
	            title: null
	        },
	        left: {
	            labels: { autoRotate: false },
	            line: null,
	            tickLine: { lineWidth: 0, stroke: "#fcc" },
	            title: null
	        },
	        right: {
	            labels: { autoRotate: false },
	            title: null
	        }
	    },
	    colors: {
	        default: COLORS,
	        intervalStack: COLORS,
	        trend: TRENDCOLORS
	    },
	    defaultColor: "#5FB6C7",
	    legend: false,
	    shape: {
	        area: { fill: "#5FB6C7" },
	        hollowPoint: { fill: "#5FB6C7" },
	        hollowInterval: { lineDash: [3, 2], lineWidth: 1 },
	        interval: { fill: "#abce5b", fillOpacity: 1, stroke: "#5FB6C7" },
	        line: { stroke: "#5FB6C7", lineWidth: 2 },
	        point: { fill: "#5FB6C7", fillOpacity: .5 }
	    },
	    tooltip: {
	        tooltipMarker: {
	            stroke: "#5FB6C7"
	        }
	    },
	    maxPlotLength: 200,
	    fontSize: "12px",
	    fontFamily: "Arial"
	};
	exports.ResizeChartType = ["retention", "retentionColumn"];


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	const G2 = __webpack_require__(5);
	const moment = __webpack_require__(9);
	const lodash_1 = __webpack_require__(2);
	/**
	 * 数字格式
	 * @param n
	 * @returns {string}
	 */
	exports.formatNumber = (n) => {
	    if (typeof n !== "number") {
	        return n;
	    }
	    // Math.对数相除
	    const suffixArray = ["", "万", "亿", "万亿"];
	    const suffixIndex = Math.max(0, Math.min(3, Math.floor(Math.log10(Math.abs(n)) / 4)));
	    if (suffixIndex < 1) {
	        if (Number.isInteger(n)) {
	            return `${n}`;
	        }
	        return parseFloat(n.toPrecision(3)).toString();
	    }
	    return parseFloat((n * Math.pow(0.1, 4 * suffixIndex)).toPrecision(3)) + suffixArray[suffixIndex];
	};
	exports.filterValuesByTickCount = (tickCount, values) => {
	    const indexs = values.map((e, i) => {
	        if (i % tickCount === 0) {
	            return i;
	        }
	    }).filter((e) => e !== undefined);
	    const fValues = values.filter((e, i) => {
	        return indexs.includes(i);
	    });
	    if (!fValues.includes(values[values.length - 1])) {
	        fValues.push(values[values.length - 1]);
	        indexs.push(values.length - 1);
	    }
	    return { indexs, values: fValues };
	};
	exports.mergeFrame = (frame, dim, indexs) => {
	    const fr = G2.Frame.filter(frame, (obj, index) => indexs.includes(obj.turn));
	    const dimIndexs = fr.colArray(dim);
	    const newIndexs = dimIndexs.map((i) => indexs.indexOf(i));
	    return fr.colReplace(dim, newIndexs);
	};
	exports.formatPercent = (n) => {
	    if (typeof n !== "number") {
	        return n;
	    }
	    if (!n) {
	        return "0%";
	    }
	    if (0 < n && n < 0.001) {
	        return "< 0.1%";
	    }
	    else if (0 > n && n > 0.001) {
	        return "> -0.1%";
	    }
	    return `${parseFloat((100 * n).toPrecision(3))}%`;
	};
	// 计量时间区间
	exports.calculateTimeRange = (timeRange) => {
	    if (!timeRange) {
	        timeRange = "day:8,1";
	    }
	    const [cate, v] = timeRange.split(":");
	    const [start, end] = v.split(",");
	    if (cate === "day") {
	        return (parseInt(start, 10) - parseInt(end, 10)) * 864e5;
	    }
	    else if (cate === "abs") {
	        return parseInt(end, 10) - parseInt(start, 10);
	    }
	    else if (cate === "week") {
	        return (parseInt(start, 10) - parseInt(end, 10)) * 6048e5;
	    }
	    else if (cate === "month") {
	        return (parseInt(start, 10) - parseInt(end, 10)) * 25920e5;
	    }
	};
	// 如果是要从倍数里面去取，小时要照顾到天
	exports.countTickCount = (frame, width, tmInterval) => {
	    const range = G2.Frame.range(frame, "tm");
	    const tmLength = G2.Frame.group(frame, ["tm"]).length;
	    // TODO: 计算tickInterval
	    const [startTime, endTime] = G2.Frame.range(frame, "tm");
	    const interval = (endTime - startTime) / width * 80;
	    if (endTime - startTime > tmInterval) {
	        return Math.ceil(interval / tmInterval) * tmInterval;
	    }
	    else if (endTime - startTime > 86400000) {
	        return Math.ceil(interval / 86400000) * 86400000;
	    }
	    else {
	        const ceilNum = Math.ceil(interval / 3600000);
	        // 取大于divisor的24的约数
	        const divisor = [24, 12, 8, 6, 4, 3, 2, 1].reduce((b, n) => (ceilNum > n ? b : n));
	        return (divisor * 3600000);
	    }
	};
	exports.getTmFormat = (tmInterval) => {
	    if (tmInterval > 6048e5) {
	        return (v) => moment.unix(v / 1000).format("MMMM");
	    }
	    else if (tmInterval === 6048e5) {
	        return (v) => (`${moment.unix(v / 1000).format("MM-DD ddd")} 到 ${moment.unix(v / 1000).endOf("week").format("MM-DD ddd")}`);
	    }
	    else if (tmInterval === 864e5) {
	        return (v) => moment.unix(v / 1000).format("MM-DD ddd");
	    }
	    else if (tmInterval === 36e5) {
	        return (v) => moment.unix(v / 1000).format("MM-DD ddd HH:mm");
	    }
	    return (v) => moment.unix(v / 1000).format("MM-DD ddd");
	};
	exports.getAxisFormat = (tmInterval) => {
	    if (tmInterval === 6048e5) {
	        return (n) => n.slice(0, 8);
	    }
	    else if (tmInterval === 36e5) {
	        return (n) => {
	            const matches = n.split(" ");
	            return (matches[1] === "00:00") ? matches[0] : matches[1];
	        };
	    }
	    return;
	};
	// 根据调整
	exports.retentionIntervalColumns = (interval, timeRange) => {
	    const mx = Math.floor(exports.calculateTimeRange(timeRange) / interval);
	    let result = [];
	    if (interval === 6048e5) {
	        result = [1, 2, 3, 4];
	    }
	    else if (interval === 25920e5) {
	        result = [1, 2, 3];
	    }
	    else if (interval === 864e5) {
	        result = [1, 7, 14, 30];
	    }
	    return lodash_1.map(lodash_1.filter(result, (n) => (n <= mx)), (n) => n.toString());
	};
	// 根据留存的数据源图形进行处理
	exports.retentionSourceSelector = (source, dimCols, overTime, interval, timeRange) => {
	    const filterSource = (overTime ? lodash_1.reject : lodash_1.filter)(source, { tm: 0 });
	    // 记录需要保留的字段
	    if (overTime) {
	        // 挑选里面的字段第1，7，14天
	        const fetchedTurns = exports.retentionIntervalColumns(interval, timeRange);
	        const results = lodash_1.filter(lodash_1.flatten(lodash_1.map(fetchedTurns, (turn) => lodash_1.map(filterSource, (s) => {
	            const v = lodash_1.pick(s, dimCols);
	            if (!s[`retention_${turn}`]) {
	                return null;
	            }
	            lodash_1.assign(v, {
	                turn,
	                retention: s[`retention_${turn}`],
	                retention_rate: s[`retention_rate_${turn}`]
	            });
	            return v;
	        }))));
	        return results;
	    }
	    const lastResult = lodash_1.map(filterSource, (s) => {
	        const reservedObj = lodash_1.pick(s, dimCols);
	        const combinedResults = lodash_1.transform(s, (result, value, key) => {
	            const matches = key.match(/^(retention(?:_rate)?)_(\d+)$/);
	            if (matches) {
	                const retention = parseInt(matches[2], 10);
	                if (!result[retention]) {
	                    result[retention] = {};
	                }
	                result[retention][matches[1]] = value;
	            }
	        }, []);
	        return lodash_1.map(combinedResults, (n, i) => lodash_1.assign(n, reservedObj, { turn: i }));
	    });
	    return lodash_1.flatten(lastResult);
	};
	exports.getRetentionParams = (chartType, columns, params, isCOT) => {
	    let compareCol = lodash_1.filter(columns, (n) => (n.id !== "tm" && n.isDim)).reverse();
	    const isCompare = !!compareCol.length;
	    // 处理 turn的问题
	    if (isCOT && !isCompare) {
	        const interval = lodash_1.find(params.granularities, { id: "tm" }).interval;
	        const timeRange = params.timeRange;
	        const filterArray = exports.retentionIntervalColumns(parseInt(interval, 10), timeRange);
	        const filteredColumns = lodash_1.filter(columns, (n) => {
	            const matches = n.id.match(/^retention(?:_rate)_(\d+)$/);
	            return (matches && filterArray.includes(matches[1]));
	        });
	        compareCol = [{ id: "turn", name: "留存周期", isDim: true, isRate: false, values: lodash_1.map(filteredColumns, "name") }];
	    }
	    const cotCols = isCOT ?
	        { id: "tm", name: "起始时间", isDim: true, isRate: false } :
	        { id: "turn", name: "留存", isDim: true, isRate: false, values: getLabels(columns) };
	    let matricCols = [
	        { id: "retention_rate", name: "留存率", isDim: false, isRate: true },
	        { id: "retention", name: "用户数", isDim: false, isRate: false }
	    ];
	    if (chartType === "count") {
	        matricCols = matricCols.reverse();
	    }
	    return {
	        adjust: "stack",
	        chartType: chartType === "count" ? "retentionColumn" : "retention",
	        columns: [cotCols, ...compareCol, ...matricCols]
	    };
	};
	const getLabels = (columns) => {
	    return lodash_1.map(lodash_1.filter(columns, (n) => (/^retention_\d+$/.test(n.id))), "name");
	};


/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_9__;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	/*
	 * ContextListener 负责监听的控件，并把context传递给Chart
	 */
	const React = __webpack_require__(3);
	const Aggregate_1 = __webpack_require__(11);
	const Chart_1 = __webpack_require__(4);
	const GrTable_1 = __webpack_require__(12);
	const utils_1 = __webpack_require__(8);
	const lodash_1 = __webpack_require__(2);
	class ContextListener extends React.Component {
	    render() {
	        const chartParams = this.generateChartParams();
	        const withAggregate = ["comparison", "singleNumber"].includes(chartParams.chartType);
	        if (chartParams.chartType === "table") {
	            return (React.createElement(GrTable_1.default, { chartParams: chartParams, extraColumns: this.props.extraColumns, source: this.context.source, select: this.props.select, selected: this.context.selected, sortHandler: this.props.sortHandler, startTime: this.context.startTime, trackWords: this.context.trackWords }));
	        }
	        else if (!this.context.source || !this.context.source.length) {
	            const outerStyle = {
	                "-webkit-box-orient": "vertical",
	                "-webkit-box-pack": "center",
	                "display": "-webkit-box",
	                "height": "100%"
	            };
	            const wordStyle = {
	                color: "#999999",
	                fontSize: 16,
	                fontWeight: 200,
	                textAlign: "center"
	            };
	            return (React.createElement("div", { style: outerStyle },
	                React.createElement("div", { style: wordStyle }, "\u6682\u65E0\u6570\u636E")));
	        }
	        else if (withAggregate) {
	            const isRate = !!(this.context.columns && this.context.columns.length > 1 && this.context.columns[1].isRate);
	            return (React.createElement("div", { className: `gr-chart-wrapper ${chartParams.chartType}` },
	                React.createElement(Aggregate_1.default, { data: this.context.aggregator.values, period: this.props.range, isRate: isRate }),
	                React.createElement(Chart_1.default, { chartParams: chartParams, colorTheme: this.props.colorTheme, source: this.context.source, select: this.props.select, selected: this.context.selected, startTime: this.context.startTime, trackWords: this.context.trackWords, isThumb: this.props.isThumb })));
	        }
	        else if (chartParams.chartType === "singleNumber") {
	            return (React.createElement("div", { className: "gr-chart-wrapper" },
	                React.createElement(Aggregate_1.default, { data: this.context.aggregator.values, period: this.props.range }),
	                React.createElement(Chart_1.default, { chartParams: chartParams, colorTheme: this.props.colorTheme, source: this.context.source, select: this.props.select, style: { height: "calc(100% - 40px)" }, selected: this.context.selected, startTime: this.context.startTime, trackWords: this.context.trackWords, isThumb: this.props.isThumb })));
	        }
	        else if (["retention", "retentionTrend"].includes(chartParams.chartType)) {
	            const source = utils_1.retentionSourceSelector(this.context.source, ["comparison_value"], false, lodash_1.find(chartParams.granularities, { id: "tm" }).interval, this.props.timeRange);
	            let values = null;
	            if (this.context.columns) {
	                values = lodash_1.map(lodash_1.filter(this.context.columns, (n) => (/^retention_\d+$/.test(n.id))), "name");
	            }
	            const retentionParams = {
	                adjust: "stack",
	                chartType: chartParams.chartType,
	                columns: [
	                    { id: "turn", name: "留存周期", isDim: true, isRate: false, values },
	                    { id: "retention", name: "用户数", isDim: false, isRate: false },
	                    { id: "retention_rate", name: "留存率", isDim: false, isRate: true }
	                ]
	            };
	            return (React.createElement(Chart_1.default, { chartParams: retentionParams, colorTheme: this.props.colorTheme, source: source, startTime: this.context.startTime, trackWords: this.context.trackWords, isThumb: this.props.isThumb }));
	        }
	        return (React.createElement(Chart_1.default, { chartParams: chartParams, source: this.context.source, select: this.props.select, selected: this.context.selected, startTime: this.context.startTime, trackWords: this.context.trackWords, isThumb: this.props.isThumb }));
	    }
	    generateChartParams() {
	        if (this.props.hasOwnProperty("chartParams")) {
	            return this.props.chartParams;
	        }
	        return {
	            adjust: this.props.adjust,
	            aggregator: this.context.aggregator,
	            chartType: this.props.chartType,
	            colorTheme: this.props.colorTheme,
	            columns: this.context.columns,
	            // 以下目前只有表格处用到
	            granularities: this.props.granularities,
	            groupCol: this.props.groupCol
	        };
	    }
	}
	ContextListener.contextTypes = {
	    aggregator: React.PropTypes.any,
	    columns: React.PropTypes.array,
	    extraColumns: React.PropTypes.any,
	    selectHandler: React.PropTypes.func,
	    selected: React.PropTypes.any,
	    source: React.PropTypes.any,
	    startTime: React.PropTypes.number,
	    trackWords: React.PropTypes.any
	};
	exports.default = ContextListener;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	/***
	 * 文档
	 */
	const React = __webpack_require__(3);
	const utils_1 = __webpack_require__(8);
	const Aggregate = (props) => {
	    const { data, period } = props;
	    return props.data ? (React.createElement("div", { className: "gr-chart-aggregate-info" },
	        React.createElement("div", { className: "gr-chart-aggregate-inner" },
	            React.createElement("div", { className: "gr-chart-aggregate-num" },
	                props.isRate ? utils_1.formatPercent(props.data[0]) : utils_1.formatNumber(props.data[0]),
	                React.createElement("span", { className: "suffix" })),
	            data[1] ? React.createElement(AggregatePercent, { percent: props.data[0] / props.data[1] - 1, period: props.period }) : null))) : null;
	};
	const AggregatePercent = (props) => (React.createElement("div", { className: "gr-chart-aggregate-percent" },
	    React.createElement("div", { className: `gr-chart-trend-${props.percent > 0 ? "up" : "down"}` },
	        React.createElement("svg", { className: "svg-icon" },
	            React.createElement("use", { href: `#icon-${props.percent > 0 ? "up" : "down"}-trend` })),
	        React.createElement("span", null, utils_1.formatPercent(Math.abs(props.percent)).slice(0, -1)),
	        React.createElement("span", { style: { fontSize: 12 } }, "%")),
	    React.createElement("span", { className: "gr-chart-trend-desc" }, props.period ? "相比上周期" : "相比7天前")));
	exports.default = Aggregate;


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	/***
	 * 文档
	 */
	const antd_1 = __webpack_require__(13);
	const lodash_1 = __webpack_require__(2);
	const moment = __webpack_require__(9);
	const React = __webpack_require__(3);
	// import Table from 'antd/lib/table';
	const G2 = __webpack_require__(5);
	const AtdTable = antd_1.Table;
	const sorterDecorator = (column) => (a, b) => (a[column] >= b[column] ? 1 : -1);
	moment.locale("zh-cn");
	// 根据中位数计算颜色,这段难理解，自己斟酌
	const calculateWeight = (range, median) => (v) => {
	    if (median === null) {
	        return "";
	    }
	    if (v > median) {
	        return `rgba(255,211,99, ${(v - median) * 0.5 / (range[1] - median)})`;
	    }
	    else if (v < median) {
	        return `rgba(95,182,199, ${(v - median) * 0.5 / (range[0] - median)})`;
	    }
	};
	// 根据metric取得背景色
	const descValue = (value, isRate) => {
	    if (value) {
	        if (isRate) {
	            return (100 * value).toPrecision(3) + "%";
	        }
	        else if (!Number.isInteger(value)) {
	            return (value >= 1000) ? Math.round(value).toString() : value.toPrecision(3);
	        }
	    }
	    if (typeof value === "string") {
	        return value;
	    }
	    if (value === null) {
	        return "";
	    }
	    return value === undefined ? undefined : value.toString();
	};
	const generateColRender = (getBgColor, m) => (value) => ({
	    children: descValue(value, m.isRate),
	    props: { style: { backgroundColor: getBgColor(value) } }
	});
	const checkDate = (m) => (m.id === "tm" ? GrTable.formatDate : undefined);
	class GrTable extends React.Component {
	    constructor() {
	        super(...arguments);
	        this.lastSorter = {};
	    }
	    static formatDate(v) {
	        return moment.unix(v / 1000).format("YYYY-MM-DD");
	    }
	    static getRowKey(r, i) {
	        return `${i}`;
	    }
	    checkDate(m) {
	        if (m.id === "tm") {
	            const gra = lodash_1.find(this.props.chartParams.granularities, { id: "tm" });
	            if (gra.interval && gra.interval > 6048e5) {
	                return (v) => moment.unix(v / 1000).format("MMMM");
	            }
	            else if (gra.interval && gra.interval >= 864e5) {
	                return (v) => moment.unix(v / 1000).format("YYYY-MM-DD");
	            }
	            else {
	                return (v) => moment.unix(v / 1000).format("YYYY-MM-DD HH:mm");
	            }
	        }
	    }
	    // 将多指标扁平成一条
	    static groupFlatter(n, groupCol, groupCols, otherDims) {
	        return n.reduce((result, value) => {
	            const i = groupCols.indexOf(value[groupCol]);
	            lodash_1.forIn(value, (v, k) => {
	                if (k === groupCol) {
	                    return;
	                }
	                else if (otherDims.includes(k)) {
	                    result[k] = value[k];
	                }
	                else {
	                    result[`${groupCol}_${i}_${k}`] = value[k];
	                }
	            });
	            return result;
	        }, {});
	    }
	    render() {
	        const chartParams = this.props.chartParams;
	        let source = this.props.source;
	        let cols = [];
	        try {
	            if (!source || !chartParams) {
	                return null;
	            }
	            if (chartParams.groupCol) {
	                const dimNames = lodash_1.difference(lodash_1.map(lodash_1.filter(chartParams.columns, "isDim"), "id"), [chartParams.groupCol]);
	                const metrics = lodash_1.filter(chartParams.columns, { isDim: false });
	                const groupColValues = lodash_1.flatMap(lodash_1.unionBy(source, chartParams.groupCol), chartParams.groupCol);
	                // TODO 按时间分组
	                const join = (row) => lodash_1.values(lodash_1.pick(row, dimNames)).join("");
	                const groupSource = lodash_1.values(lodash_1.groupBy(source, join));
	                source = lodash_1.map(groupSource, (n) => GrTable.groupFlatter(n, chartParams.groupCol, groupColValues, dimNames));
	                const frame = new G2.Frame(source);
	                // 分三段
	                cols = lodash_1.map(dimNames, (id) => ({
	                    dataIndex: id,
	                    key: id,
	                    sorter: sorterDecorator(id),
	                    title: lodash_1.find(chartParams.columns, { id }).name
	                }));
	                const metricCols = groupColValues.map((name, i) => ({
	                    title: name,
	                    children: lodash_1.map(metrics, (m) => {
	                        const id = `${chartParams.groupCol}_${i}_${m.id}`;
	                        return {
	                            className: "metric",
	                            dataIndex: id,
	                            key: id,
	                            render: generateColRender(calculateWeight(G2.Frame.range(frame, id), G2.Frame.median(frame, id)), m),
	                            sorter: sorterDecorator(id),
	                            title: m.name,
	                        };
	                    })
	                }));
	                cols = cols.concat(metricCols);
	            }
	            else {
	                const frame = new G2.Frame(source);
	                cols = chartParams.columns.map((m, i) => ({
	                    className: m.isDim ? undefined : "metric",
	                    dataIndex: m.id,
	                    key: `${m.id}_${i}`,
	                    render: (m.isDim ?
	                        this.checkDate(m) :
	                        generateColRender(calculateWeight(G2.Frame.range(frame, m.id), G2.Frame.median(frame, m.id)), m)),
	                    sorter: sorterDecorator(m.id),
	                    title: m.name,
	                }));
	            }
	            // hardcode
	            if (this.props.hasOwnProperty("extraColumns") && this.props.extraColumns) {
	                const extraColumns = this.props.extraColumns;
	                if (!lodash_1.find(cols, { dataIndex: extraColumns.dataIndex })) {
	                    if (!extraColumns.render) {
	                        extraColumns.render = ((v) => v);
	                    }
	                    cols = cols.concat(extraColumns);
	                }
	            }
	            /*
	             if (this.context.selected) {
	             let selected = this.context.selected;
	             let cols = Object.keys(selected);
	             source = filter(source, (n: any) => every(cols,
	             (c: string) => (n[c] >= selected[c][0] && n[c] <= selected[c][1])
	             ));
	             }*/
	            // 这步就是成功
	            return (React.createElement(AtdTable, { bordered: true, columns: cols, dataSource: source, emptyText: () => "", pagination: source.length > 10 ? { pageSize: 10 } : false, rowKey: GrTable.getRowKey, onChange: this.onChange.bind(this), ref: this.onLoad.bind(this) }));
	        }
	        catch (e) {
	            this.track("report_render_fail");
	            return null;
	        }
	        // TODO: 增加selected处理
	    }
	    onLoad(e) {
	        if (e) {
	            this.track("report_render_success");
	        }
	    }
	    track(trackKey) {
	        try {
	            const vds = window._vds;
	            vds.track(trackKey, {
	                project_id: window.project.id,
	                chart_name: this.props.trackWords.name,
	                board_name: this.props.trackWords.board_name,
	                report_load_time: Date.now() - this.props.startTime,
	                channel_name: this.props.trackWords.channel_name
	            });
	        }
	        catch (e) {
	            return;
	        }
	    }
	    onChange(pagination, filters, sorter) {
	        if (!lodash_1.isEqual(this.lastSorter, sorter)) {
	            this.props.sortHandler(sorter);
	            this.lastSorter = sorter;
	        }
	    }
	}
	exports.default = GrTable;


/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_13__;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	/***
	 * 文档
	 */
	const lodash_1 = __webpack_require__(2);
	const React = __webpack_require__(3);
	const DataCache = __webpack_require__(15);
	// 数据统计必备字段，中端需要以下字段提供数据
	exports.HttpStatus = {
	    Ok: 200,
	    Created: 201,
	    NoContent: 204,
	    MovedPermanently: 301,
	    SeeOther: 303,
	    NotModified: 304,
	    BadRequest: 400,
	    Unauthorized: 401,
	    Forbidden: 403,
	    NotFound: 404,
	    MethodNotAllowed: 405,
	    NotAcceptable: 406,
	    RequestTimeout: 408,
	    UnsupportedEntity: 422,
	    Locked: 423,
	    TooManyRequests: 429,
	    InternalServerError: 500,
	    NotImplemented: 501
	};
	const getErrorMsg = (data) => {
	    let errorMsg = "";
	    try {
	        errorMsg = JSON.parse(data);
	        errorMsg = errorMsg.message;
	        if (typeof errorMsg === "string") {
	            errorMsg = JSON.parse(errorMsg);
	            errorMsg = errorMsg.reason;
	        }
	    }
	    catch (e) {
	        errorMsg = "网络错误";
	    }
	    return errorMsg;
	};
	class DataSource extends React.Component {
	    constructor(props) {
	        super(props);
	        this.tryTimes = 0;
	        this.startTime = 0;
	        this.trackWords = {
	            board_name: "",
	            channel_name: "",
	            name: ""
	        };
	        this.xhr = "";
	        // 加载状态
	        this.state = {
	            aggregator: null,
	            columns: null,
	            error: false,
	            loading: true,
	            selected: null,
	            source: null
	        };
	    }
	    render() {
	        if (this.state.error) {
	            const errorWord = {
	                101: "数据加载失败",
	                102: "业务计算超时"
	            };
	            return (React.createElement("div", { className: "chart-error" },
	                React.createElement("div", null,
	                    "\u62B1\u6B49\uFF0C",
	                    errorWord[this.state.error],
	                    React.createElement("br", null),
	                    "\u8BF7\u7A0D\u540E\u91CD\u8BD5")));
	        }
	        else if (this.state.loading) {
	            return (React.createElement("div", { className: "gr-loading-mask" },
	                React.createElement("div", { className: "loading-gif" })));
	        }
	        return React.Children.only(this.props.children);
	    }
	    // TODO: 用来给子孙节点中的GrChart自定义 Demo props state改变触发 DataSource取数据返回触发
	    getChildContext() {
	        return {
	            aggregator: this.state.aggregator,
	            columns: this.state.columns,
	            selected: this.state.selected,
	            source: this.state.source,
	            startTime: this.startTime,
	            trackWords: this.trackWords
	            /*,
	             selectHandler: this.selectHandler.bind(this)
	             */
	        };
	    }
	    componentWillReceiveProps(nextProps) {
	        // TODO status改变也会触发，所以多了一层判断
	        if (!lodash_1.isEqual(this.props.params, nextProps.params)) {
	            if (nextProps.hasOwnProperty("cacheOptions")) {
	                const chartDataInCache = DataCache.getChartData(nextProps.params, nextProps.hashKeys);
	                if (chartDataInCache) {
	                    this.setState(chartDataInCache);
	                    return;
	                }
	            }
	            this.startTime = Date.now();
	            this.setState({ error: false, loading: true });
	            this.defaultRequest(nextProps.params, this.afterFetch.bind(this));
	        }
	    }
	    defaultRequest(chartParams, callback) {
	        if (this.xhr) {
	            this.xhr.abort();
	        }
	        const xhr = new XMLHttpRequest();
	        // Todo 检查是否是DEV环境
	        if (this.props.hasOwnProperty("sourceUrl")) {
	            xhr.open("get", this.props.sourceUrl, true);
	            xhr.send(null);
	        }
	        else {
	            xhr.open("post", `${window.gateway}/_private/v4/projects/${project.id}/chartdata`, true);
	            xhr.timeout = 6e4;
	            xhr.withCredentials = true;
	            xhr.setRequestHeader("credentials", "include");
	            xhr.setRequestHeader("accept", "application/json");
	            xhr.setRequestHeader("Content-Type", "application/json");
	            xhr.send(JSON.stringify(chartParams));
	        }
	        xhr.onreadystatechange = () => {
	            if (xhr.readyState === 4) {
	                if (xhr.status === exports.HttpStatus.Ok) {
	                    const data = JSON.parse(xhr.responseText);
	                    callback(data, chartParams);
	                }
	                else if (xhr.status === exports.HttpStatus.RequestTimeout && this.tryTimes < 2) {
	                    this.tryTimes++;
	                    setTimeout(this.defaultRequest.bind(this, chartParams, callback), 200);
	                }
	                else {
	                    this.setState({
	                        error: xhr.status === exports.HttpStatus.RequestTimeout ? 102 : 101,
	                        loading: false
	                    });
	                    const vds = window._vds;
	                    vds && vds.track("report_load_fail", {
	                        project_id: window.accountId,
	                        project_name: window.project.name,
	                        chart_name: chartParams.name,
	                        board_name: this.trackWords.board_name,
	                        report_load_time: Date.now() - this.startTime,
	                        channel_name: this.trackWords.channel_name,
	                        error_msg: getErrorMsg(xhr.responseText)
	                    });
	                }
	            }
	        };
	        xhr.ontimeout = (e) => {
	            if (xhr.abort) {
	                xhr.abort();
	            }
	            this.setState({ error: 102, loading: false });
	            const vds = window._vds;
	            if (vds && vds.track) {
	                vds.track("report_load_fail", {
	                    project_id: window.accountId,
	                    project_name: window.project.name,
	                    chart_name: chartParams.name,
	                    board_name: this.trackWords.board_name,
	                    report_load_time: Date.now() - this.startTime,
	                    channel_name: this.trackWords.channel_name,
	                    error_msg: getErrorMsg(xhr.responseText)
	                });
	            }
	        };
	    }
	    componentWillMount() {
	        const { params } = this.props;
	        try {
	            const trackWords = location.pathname.match(/\/projects\/\w{8}\/([^\/]+)(?:\/([^\/]+))?/);
	            if (trackWords && trackWords.length > 2) {
	                this.trackWords = {
	                    channel_name: trackWords[1],
	                    board_name: trackWords[2],
	                    name: params.name
	                };
	            }
	        }
	        catch (e) {
	            // void(0);
	        }
	        if (this.props.hasOwnProperty("cacheOptions")) {
	            const chartDataInCache = DataCache.getChartData(params, this.props.hashKeys);
	            if (chartDataInCache) {
	                this.setState(chartDataInCache);
	                return;
	            }
	        }
	        this.startTime = Date.now();
	        this.defaultRequest(params, this.afterFetch.bind(this));
	    }
	    componentWillUnmount() {
	        if (this.xhr) {
	            this.xhr.abort();
	        }
	    }
	    afterFetch(chartData, params) {
	        this.xhr = null;
	        if (!lodash_1.isEqual(params, this.props.params)) {
	            // 说明这个请求已经废弃了
	            return;
	        }
	        let columns = chartData.meta.columns;
	        columns.forEach((n) => {
	            if (!n.isDim && n.metricId && n.metricId.action) {
	                n.id += ("_" + n.metricId.action || "");
	            }
	        });
	        // 清洗columns
	        // columns = uniqBy(columns, "id");
	        let colIds = lodash_1.map(columns, "id");
	        const offset = chartData.meta.offset;
	        // any是因为下面的zipWith返回的schema有bug
	        let sourceData = chartData.data;
	        // 为了支持周期对比图，这里需要meta的offset 转化
	        if (chartData.meta.offset !== undefined) {
	            // 寻找粒度
	            const offsetPeriod = (7 * 86400000);
	            // 强行配对，没验证...
	            sourceData = lodash_1.zipWith(sourceData.slice(0, offset), sourceData.slice(offset), (thisTurn, lastTurn) => (thisTurn || [lastTurn[0] + offsetPeriod, null]).concat(lastTurn));
	            // 加上下划线表示上一周期的字段
	            colIds = colIds.concat(lodash_1.map(colIds, (n) => (n + "_")));
	            // 取得Metric ID
	            columns[1].name = "当前周期";
	            columns = columns.concat(lodash_1.map(columns, (n) => lodash_1.assign({}, n, {
	                id: n.id + "_",
	                name: n.isDim ? undefined : "上一周期"
	            })));
	        }
	        const source = lodash_1.map(sourceData, (n) => lodash_1.zipObject(colIds, n));
	        // 强行添加转化率
	        if (params.attrs && params.attrs.isAddFakeMetric) {
	            const lastCol = columns[columns.length - 1];
	            lastCol.name += "转化率";
	            lastCol.isRate = true;
	            const id = lastCol.id;
	            source.forEach((n) => {
	                if (n["9yGbpp8x"]) {
	                    n[id] /= n["9yGbpp8x"];
	                }
	                else {
	                    n[id] = undefined;
	                }
	            });
	        }
	        // 加载成功，打点
	        if (!source || source.length === 0) {
	            try {
	                const vds = window._vds;
	                vds.track("report_no_data", {
	                    project_id: window.accountId,
	                    project_name: window.project.name,
	                    chart_name: params.name,
	                    board_name: this.trackWords.board_name,
	                    report_load_time: Date.now() - this.startTime,
	                    channel_name: this.trackWords.channel_name,
	                    params: JSON.stringify(params)
	                });
	            }
	            catch (e) {
	                void (0);
	            }
	        }
	        const state = {
	            aggregator: chartData.meta.aggregator || null,
	            columns,
	            error: false,
	            loading: false,
	            source
	        };
	        if (this.props.hasOwnProperty("cacheOptions")) {
	            DataCache.setChartData(params, state, this.props.hashKeys, this.props.cacheOptions);
	        }
	        this.setState(state);
	        if (this.props.onLoad) {
	            this.props.onLoad(this.state);
	        }
	    }
	}
	DataSource.childContextTypes = {
	    aggregator: React.PropTypes.any,
	    columns: React.PropTypes.array,
	    selectHandler: React.PropTypes.func,
	    selected: React.PropTypes.any,
	    source: React.PropTypes.any,
	    startTime: React.PropTypes.number,
	    trackWords: React.PropTypes.any
	};
	exports.default = DataSource;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	 * 脱离redux的chart数据缓存
	 * { cacheKey: {expire, chartData}}
	 */
	const objectHash = __webpack_require__(16);
	const lodash_1 = __webpack_require__(2);
	let chartDataCache = {};
	/**
	 * 将默认的获取chartData的接口
	 * @chartParams 请求参数
	 * @hashKeys 需要做hash的key
	 * return  返回生成的cacheKey
	 */
	function _generateCacheKey(params, hashKeys) {
	    let cacheKey = "";
	    // 如果从外部传来hashKeys，则用hashKeys生成缓存的key;
	    if (hashKeys) {
	        cacheKey = objectHash(hashKeys);
	    }
	    else {
	        cacheKey = objectHash(params);
	    }
	    return cacheKey;
	}
	/**
	 * 清空缓存
	 * return
	 */
	function cleanCache(cacheKey) {
	    if (cacheKey) {
	        // console.log(`%c chartDataCache: cleanCache`, `color: #4CAF50; font-weight: bold`, chartDataCache[cacheKey]);
	        delete chartDataCache[cacheKey];
	    }
	    else {
	        chartDataCache = {};
	    }
	}
	exports.cleanCache = cleanCache;
	/**
	 * 缓存中插入数据并设置过期时间
	 * return
	 */
	function setChartData(params, chartData, hashKeys, cacheOptions) {
	    // 设置缓存key
	    const cacheKey = _generateCacheKey(params, hashKeys);
	    let ttl = -1;
	    const cacheObj = {};
	    // 加上过期时间戳
	    if (cacheOptions
	        && !isNaN(cacheOptions.ttl)
	        && parseInt(cacheOptions.ttl, 10) !== -1
	        && cacheOptions.ttl * 60 * 1000 !== 0) {
	        ttl = cacheOptions.ttl * 60 * 1000 + Date.now();
	    }
	    cacheObj[cacheKey] = { ttl, chartData };
	    lodash_1.assign(chartDataCache, cacheObj);
	    // console.log(`%c chartDataCache: setChartData`, `color: #4CAF50; font-weight: bold`, cacheObj);
	}
	exports.setChartData = setChartData;
	/**
	 * 根据cacheKey和expire判断缓存中取数据
	 * return
	 */
	function getChartData(params, hashKeys) {
	    let cacheKey = "";
	    let cacheData = null;
	    let isExpire;
	    cacheKey = _generateCacheKey(params, hashKeys);
	    if (chartDataCache[cacheKey]) {
	        // 检查缓存数据是否过期
	        isExpire = chartDataCache[cacheKey].ttl !== -1 && chartDataCache[cacheKey].ttl < Date.now();
	        if (!isExpire) {
	            cacheData = chartDataCache[cacheKey].chartData;
	        }
	        else {
	            // 清除过期数据
	            cleanCache(cacheKey);
	        }
	    }
	    // console.log(`%c chartDataCache: getChartData`, `color: #4CAF50; font-weight: bold`);
	    return cacheData;
	}
	exports.getChartData = getChartData;
	/**
	 * 返回整个chart缓存，供外部使用
	 * return
	 */
	function getChartDataCache() {
	    return chartDataCache;
	}
	exports.getChartDataCache = getChartDataCache;


/***/ },
/* 16 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_16__;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	const lodash_1 = __webpack_require__(2);
	// 计算timeRange的时间长度
	const calculateTimeRange = (timeRange) => {
	    if (!timeRange) {
	        timeRange = "day:8,1";
	    }
	    const [cate, v] = timeRange.split(":");
	    const [start, end] = v.split(",");
	    if (cate === "day") {
	        return (parseInt(start, 10) - parseInt(end, 10)) * 864e5;
	    }
	    else if (cate === "abs") {
	        return parseInt(end, 10) - parseInt(start, 10);
	    }
	    else if (cate === "week") {
	        return (parseInt(start, 10) - parseInt(end, 10)) * 6048e5;
	    }
	    else if (cate === "month") {
	        return (parseInt(start, 10) - parseInt(end, 10)) * 25920e5;
	    }
	};
	/**
	 * 根据interval和timeRange筛选Turn的条件;
	 * @param interval
	 * @param timeRange
	 * @returns {string[]}
	 */
	exports.retentionIntervalColumns = (interval, timeRange) => {
	    const mx = Math.floor(calculateTimeRange(timeRange) / interval);
	    let result = [];
	    if (interval === 6048e5) {
	        result = [1, 2, 3, 4];
	    }
	    else if (interval === 25920e5) {
	        result = [1, 2, 3];
	    }
	    else if (interval === 864e5) {
	        result = [1, 7, 14, 30];
	    }
	    return lodash_1.map(lodash_1.filter(result, (n) => (n <= mx)), (n) => n.toString());
	};
	exports.getRetention = (columns, source, params, isCOT, isTrend) => {
	    // 这里服务器返回的实际是string
	    const interval = lodash_1.find(params.granularities, { id: "tm" }).interval;
	    const timeRange = params.timeRange;
	    const filterArray = (isCOT || !isTrend) ?
	        exports.retentionIntervalColumns(parseInt(interval, 10), timeRange) :
	        lodash_1.reduce(columns, (result, n) => {
	            const matches = n.id.match(/^retention(?:_rate)_(\d+)$/);
	            if (matches) {
	                result.push(matches[1]);
	            }
	            return result;
	        }, []);
	    const compareCol = lodash_1.filter(columns, (n) => (n.id !== "tm" && n.isDim)).reverse();
	    const isCompare = !!compareCol.length;
	    const retentionDimCols = getRetentionDimCols(columns, isCOT, isTrend, isCompare, filterArray);
	    const dimColumnIds = lodash_1.map(retentionDimCols, "id");
	    const retentionSource = getRetentionSource(source, isCOT, dimColumnIds, filterArray);
	    // 取得source
	    let matricCols = [
	        { id: "retention_rate", name: "留存率", isDim: false, isRate: true },
	        { id: "retention", name: "用户数", isDim: false, isRate: false }
	    ];
	    if (!isTrend) {
	        matricCols = matricCols.reverse();
	    }
	    return {
	        params: {
	            adjust: "stack",
	            chartType: isTrend ? "retention" : "retentionColumn",
	            columns: [...retentionDimCols, ...matricCols]
	        },
	        source: retentionSource
	    };
	};
	const getRetentionSource = (source, isCOT, dimColumnIds, filterArray) => {
	    const j = (isCOT ? lodash_1.reject : lodash_1.filter)(source, { tm: 0 });
	    return lodash_1.reduce(j, (result, s, key) => {
	        const dimObj = lodash_1.pick(s, dimColumnIds);
	        lodash_1.forEach(filterArray, (turn) => {
	            if (s[`retention_${turn}`]) {
	                result.push(lodash_1.assign({
	                    turn,
	                    retention: s[`retention_${turn}`],
	                    retention_rate: s[`retention_rate_${turn}`]
	                }, dimObj));
	            }
	        });
	        return result;
	    }, []);
	};
	/**
	 * 取得retentionParams
	 */
	const getRetentionDimCols = (columns, isCOT, isTrend, isCompare, filterArray) => {
	    let compareCol = isCompare ?
	        lodash_1.filter(columns, (n) => (n.id !== "tm" && n.isDim)).reverse() :
	        [];
	    // 处理 turn的问题
	    if (isCOT && !isCompare) {
	        const filteredColumns = lodash_1.filter(columns, (n) => {
	            const matches = n.id.match(/^retention(?:_rate)_(\d+)$/);
	            return (matches && lodash_1.includes(filterArray, matches[1]));
	        });
	        compareCol = [{
	                id: "turn",
	                name: "留存周期",
	                isDim: true,
	                isRate: false,
	                values: lodash_1.map(filteredColumns, "name")
	            }];
	    }
	    const cotCols = isCOT ?
	        { id: "tm", name: "起始时间", isDim: true, isRate: false } :
	        { id: "turn", name: "留存", isDim: true, isRate: false, values: getLabels(columns) };
	    let matricCols = [
	        { id: "retention_rate", name: "留存率", isDim: false, isRate: true },
	        { id: "retention", name: "用户数", isDim: false, isRate: false }
	    ];
	    if (!isTrend) {
	        matricCols = matricCols.reverse();
	    }
	    return [cotCols, ...compareCol];
	};
	const getLabels = (columns) => {
	    return lodash_1.map(lodash_1.filter(columns, (n) => (/^retention_\d+$/.test(n.id))), "name");
	};


/***/ }
/******/ ])
});
;